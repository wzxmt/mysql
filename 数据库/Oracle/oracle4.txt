
========================老男孩Linux运维-上海2期-MySQL-day18==============
上集回顾:

1. MySQL参数优化
"双一标准"
innodb_flush_log_at_trx_commit=1
0:每秒钟刷新日志缓冲区的redo到OS缓存,然后再到磁盘
1:每次事务提交,立即刷日志缓冲区,先到OS缓存,然后到磁盘
2:每次事务提交,立即刷日志缓冲区到OS,然后每秒,刷新到次哦按
配合:刷盘策略
log buffer:
data buffer 
innodb_flush_metod=
o_Direct
O_DSYNC
Fdatasync
sync_binlog=1
innodb_buffer_pool_size=  物理内存60-70
show engine innodb status\G

key_buffer_size=
Myisam 索引
tmp临时表,内存位置


2. Oracle安装和基本配置
安装:
./runInstaller 
netca
dbaca
基本配置:
用户限制调整
开启归档

基本链接

远程连接:
sqlplus system/oracle@10.0.0.58:1521/orcl 
sqlplus system/oracle@orcl 

本地ORACLE_SID
sqlplus system/oracle 
sqlplus hr/hr
sqlplus / as sysdba
========================================
3. Oracle网络管理
3.0 Oracle远程连接模型
3.1 lisener配置
	listener.ora---->listener服务器端配置文件

服务的自动注册	:
监听默认是,自动注册模式,由pmon进行自动完成,但是会有延时.
导致远程的用户会有一段时间连接不上的情况.
我们可以通过alter system register;  强制让pmon先注册实例到监听

服务的手工注册
# listener.ora Network Configuration File: /u01/app/oracle/product/11.2.0/db_1/network/admin/listener.ora
# Generated by Oracle configuration tools.
SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (GLOBAL_DBNAME = orcl)
      (ORACLE_HOME = /u01/app/oracle/product/11.2.0/db_1)
      (SID_NAME = orcl)
    )
  )

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = db08)(PORT = 1521))
    )
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )

ADR_BASE_LISTENER = /u01/app/oracle

3.2 tnsnames.ora配置:
tnsnames.ora---->客户端用来解析的配置文件 	

[oracle@db08 admin]$ cat tnsnames.ora 
# tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0/db_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

OLDGUO =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.58)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = orcl)
    )
  )

ORCL =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = db08)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
  )

3.3 监听常用管理命令
lsnrctl status 
lsnrctl stop
lsnrctl start 
tnsping oldguo
netca
netmgr  
  
4.Oracle 用户、权限、角色管理

4.1概念介绍

用户：
对数据库的访问需要以适当的身份通过验证，这就是用户的作用；每个Oracle用户都有自己的用户名和密码，并且拥有他们所创建的任意表、视图和其他资源，需要注意的是新创建的用户连最基本的访问登入Oracle的权限都没有，所以后续需要授予不同的权限和角色来达成不同的操作目的；

实体权限：权限一般分为系统权限和对象权限，系统权限可以通俗地理解为将数据库对象从无到有或从有到无的创建操作，比如说创建和删除表、视图、存储过程、session等这些操作都可以认为是系统权限；对象权限赋予了你在不同的数据库对象上操作的能力，比如DELETE权限允许你对表和视图删除行，SELETE权限允许你对表、视图、序列等进行查询操作！至于系统权限和对象权限分别有哪些，具体请参照Oracle官网，这里不再详细解释！


角色：如果多个新建用户需要后续赋予10不等的不同权限，一般方法是需要将10个不等的权限分别列出来进行授予，不但麻烦而且重用性不高，角色的出现就是为了解决这个问题。Oracle角色是一组权限的集合。正常情况下我们可以授予角色一些权限，然后将角色分配给适当的用户；


4.2 权限分类

4.2.1 管理相关权限
DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。
RESOURCE:拥有Resource权限的用户只可以创建对象，不可以创建数据库结构。
CONNECT:拥有Connect权限的用户可以登录Oracle，不可以创建实体，不可以创建数据库结构。
4.2.2 普通对象权限
select, update, insert, alter, index, delete --->all 代表所有权限
execute -->执行存储过程权限


4.3 用户管理及授权

4.3.1 创建用户的Profile文件

SQL> create profile student limit // student为资源文件名
FAILED_LOGIN_ATTEMPTS 3 //指定锁定用户的登录失败次数
PASSWORD_LOCK_TIME 5   //指定用户被锁定天数
PASSWORD_LIFE_TIME 30 //指定密码过期时间

## 例子：
create profile test limit 
FAILED_LOGIN_ATTEMPTS 3 
PASSWORD_LOCK_TIME 5
PASSWORD_LIFE_TIME 30;


4.3.2 创建用户
SQL> Create User username
Identified by password
Default Tablespace tablespace
Temporary Tablespace tablespace
Profile profile
Quota integer/unlimited on tablespace;

## 例:
SQL> Create user oldguo
identified by oldguo 
default tablespace users
temporary tablespace temp
profile test
quota 50m on users;

========
tablespace
参数查询:
show parameter   ----->show variables 
数据字典视图(查询元数据方法):
dba_xxxxs
user_xxxs
           ------->information_schema
动态性能视图:
v$xxxxx      ----->show  status
=========================
4.3.3 查询用户默认表空间、临时表空间
SQL> select username, default_tablespace, temporary_tablespace from dba_users;

4.3.4 查询系统配置文件名
SQL> select * from dba_profiles;
SQL> select * from dba_profiles where profile='TEST';


## 配置文件类似表，一旦创建就会保存在数据库中。
SQL> select username, profile, default_tablespace, temporary_tablespace from dba_users;

4.3.5  查询用户会话信息：
SQL> select username, sid, serial#, machine from v$session;
## 删除用户会话信息：
SQL> Alter system kill session 'sid, serial#';


4.3.5 修改用户

SQL> Alter User 用户名
Identified 口令
Default Tablespace tablespace
Temporary Tablespace tablespace
Profile profile
Quota integer/unlimited on tablespace;



## 修改用户配置文件
SQL> create profile common limit
failed_login_attempts 5
idle_time 5;

SQL> Alter user oldguo profile common;

## 修改口令：
SQL>Alter user oldguo identified by "12345";

## 修改用户缺省表空间：
SQL> create tablespace test datafile '/oradata/test.dbf' size 20M;
SQL> Alter user oldguo default tablespace test;

## 修改用户临时表空间
SQL> create temporary tablespace temp_data
    tempfile '/oradata/temp_data.dbf' size 20M;
SQL> Alter user oldguo temporary tablespace temp_data;

## 强制用户修改口令字：
SQL> Alter user oldguo password expire;

##将用户加锁
SQL> Alter user oldguo account lock; // 加锁
SQL> Alter user oldguo account unlock; // 解锁


4.3.6 删除用户(危险动作)
SQL> drop user 用户名; //用户没有建任何实体
SQL> drop user 用户名 CASCADE; // 将用户及其所建实体全部删除
SQL> drop user oldguo cascade;   

===============================
4.3.7创建用户及授权管理权限
SQL> create user user50 identified by user50;
SQL> grant connect, resource to user50;
SQL> conn user50/user50
SQL> create table t1(id int,name varchar2(20));
SQL> insert into t1 values(1,'zs');
SQL> commit;
SQL> select * from t1;
SQL> select table_name from user_tables;

## 查询用户拥有哪些权限：
conn system/oracle
set linesize 200;
select * from dba_role_privs where grantee='USER50';
select * from dba_sys_privs where grantee='USER50';

4.3.8 系统权限传递
增加WITH ADMIN OPTION选项，则得到的权限可以传递。
grant connect, resorce to user50 with admin option; 

4.3.9系统权限回收
系统权限只能由DBA用户回收
Revoke connect, resource from user50;

##普通对象权限管理
SQL> create user user01 identified by 123;
SQL> create user user02 identified by 123;
SQL> grant select, update, insert on t1 to user01;
SQL> grant all on t1 to user02;

##将表的操作权限授予全体用户：
SQL> grant all on t1 to public; 

## 用户可以查询的表
SQL> select owner, table_name from all_tables; 
## 用户创建的表
SQL> select table_name from user_tables; 
## 获权可以存取的表（被授权的）
SQL> select grantor, table_schema, table_name, privilege from all_tab_privs; 
 // 授出权限的表(授出的权限)
SQL> select grantee, owner, table_name, privilege from user_tab_privs;


管理角色
## 建一个角色
sql>create role role1;

## 授权给角色
sql>grant create any table,create procedure to role1;

## 授予角色给用户
SQL> create user user1 identified by 123;
SQL> grant role1 to user1;

## 查看角色所包含的权限
SQL> select * from role_sys_privs where ROLE='ROLE1';

## 创建带有口令以角色(在生效带有口令的角色时必须提供口令)
sql>create role role1 identified by password1;
## 修改角色：是否需要口令
sql>alter role role1 not identified;
sql>alter role role1 identified by password1;


## 设置当前用户要生效的角色
(注：角色的生效是一个什么概念呢？假设用户a有b1,b2,b3三个角色，那么如果b1未生效，则b1所包含的权限对于a来讲是不拥有的，只有角色生效了，角色内的权限才作用于用户，最大可生效角色数由参数MAX_ENABLED_ROLES设定；在用户登录后，oracle将所有直接赋给用户的权限和用户默认角色中的权限赋给用户。）
sql>set role role1;//使role1生效
sql>set role role,role2;//使role1,role2生效
sql>set role role1 identified by password1;//使用带有口令的role1生效
sql>set role all;//使用该用户的所有角色生效
sql>set role none;//设置所有角色失效
sql>set role all except role1;//除role1外的该用户的所有其它角色生效。
sql>select * from SESSION_ROLES;//查看当前用户的生效的角色。
## 修改指定用户，设置其默认角色
sql>alter user user1 default role role1;
sql>alter user user1 default role all except role1;
详见oracle参考文档
## 删除角色
sql>drop role role1;
角色删除后，原来拥用该角色的用户就不再拥有该角色了，相应的权限也就没有了
=====================================
用户,权限,角色
create user user1 identified by 123 ;
grant connect ,resource to user1;
grant connect ,resource,dba to user2;
user   ---->  schema ---->   对象
=====================================
Oracle 文件管理

startup
nomount  ---->mount   ----open

1.参数文件: 

(1)作用:
影响Oracle数据库的启动
(2)文件内容:
*.audit_file_dest='/u01/app/oracle/admin/orcl/adump'
*.audit_trail='db'
*.compatible='11.2.0.4.0'

控制文件的位置:
*.control_files='/oradata/orcl/control01.ctl','/oradata/orcl/control02.ctl'
数据库块大小:
*.db_block_size=8192
*.db_domain=''
*.db_name='orcl'

存放诊断日志信息:
*.diagnostic_dest='/u01/app/oracle'
归档日志目录:
*.log_archive_dest_1='location=/u01/arch'
Oracle总内存大小设置(动态管理PGA(用户进程sp工作区域),SGA(shared pool ,data buffer,log buffer)):
*.memory_target=833617920
Oracle 打开游标的数量
*.open_cursors=300
Oracle 用户的连接数
*.processes=150
远程用户登录使用密码文件
*.remote_login_passwordfile='EXCLUSIVE'
*.sessions=170
undo表空间的位置
*.undo_tablespace='UNDOTBS1'


Oracle在读取完成参数文件后,应用了相应参数之后,会到达nomount








如何转换spfile与pfile

## spfile-->pfile
SQL> create pfile from spfile;
SQL> !ls $ORACLE_HOME/dbs/initorcl.ora
/u01/app/oracle/product/11.2.0/db_1/dbs/initorcl.ora
## 生成在指定路径
SQL> create pfile='/tmp/initorcl.ora' from spfile;
## pfile-->spfile
SQL> create spfile='/tmp/spfileorcl.ora' from pfile;
可以用strings命令查看创建的spfile文件，查出来的结过和pfile是一样的。

修改pfile配置后,重新倒回spfile
shutdown immediate
create spfile='/u01/app/oracle/product/11.2.0/db_1/dbs/spfileorcl.ora' from pfile='/tmp/aa.txt';
startup

手工指定pfile启动数据库
shutdown immediate;
startup pfile='/tmp/aa.txt'



6.1.4 判断数据库从SPFILE还是PFILE启动
## 方式1：
如果是spfile，则value是有值的
SQL> show parameter spfile

NAME                     TYPE    VALUE
------------------------------------ ---------- ------------------------------
spfile                     string    /u01/app/oracle/product/11.2.0
                        /db_1/dbs/spfileorcl.ora
						
## 方式2：
SQL> set linesize 120
SQL> col name format a10
SQL> col value format a60
SQL> select name,value from v$parameter where name='spfile';

NAME             VALUE
-------------------- ------------------------------------------------------------
spfile             /u01/app/oracle/product/11.2.0/db_1/dbs/spfileorcl.ora



控制文件管理:

控制文件添加:
show parameter control;
shutdown immediate;
cd /oradata/orcl/
cp control01.ctl /u01/app/oracle/control03.ctl
cp control01.ctl /u01/app/oracle/control04.ctl
SQL> create pfile='/tmp/init.ora' from spfile;
SQL> !vim /tmp/init.ora

*.control_files='/oradata/orcl/control01.ctl','/oradata/orcl/control02.ctl','/u01/app/oracle/control03.ctl','/u01/app/oracle/control04.ctl'

SQL> create spfile from pfile='/tmp/init.ora';
SQL> startup
SQL> show parameter control;


控制1个文件损坏修复
SQL>  ! rm -rf /oradata/orcl/control01.ctl
SQL>  ! ls -l /oradata/orcl/
SQL> shutdown immediate
Database closed.
ORA-00210: cannot open the specified control file
ORA-00202: control file: '/oradata/orcl/control01.ctl'
ORA-27041: unable to open file
Linux-x86_64 Error: 2: No such file or directory
Additional information: 3

修复过程:
1.强制关闭数据库
SQL> shutdown abort
2.尝试启动数据库
SQL> startup
ORACLE instance started.

Total System Global Area  405057536 bytes
Fixed Size		    2253624 bytes
Variable Size		  272633032 bytes
Database Buffers	  125829120 bytes
Redo Buffers		    4341760 bytes
ORA-00205: error in identifying control file, check alert log for more info


[oracle@db08 orcl]$ cd /u01/app/oracle/diag/rdbms/orcl/orcl/trace
[oracle@db08 trace]$ ls -l alert_*
-rw-r----- 1 oracle oinstall 62811 Dec  7 09:19 alert_orcl.log

ORA-00210: cannot open the specified control file
ORA-00202: control file: '/oradata/orcl/control01.ctl'
ORA-27037: unable to obtain file status
Linux-x86_64 Error: 2: No such file or directory

3.处理问题
SQL> shutdown abort
[oracle@db08 orcl]$ cp control02.ctl control01.ctl 

SQL> select file_name from dba_data_files;
SQL> select group#,member from v$logfile;
SQL> alter database backup controlfile to trace;
SQL> select tracefile from v$process where addr in (select paddr from v$session where sid in (select sid from v$mystat)); 


模拟所有控制文件损坏修复:

重建控制文件:

STARTUP NOMOUNT
CREATE CONTROLFILE REUSE DATABASE "ORCL" RESETLOGS  ARCHIVELOG
    MAXLOGFILES 16
    MAXLOGMEMBERS 3
    MAXDATAFILES 100
    MAXINSTANCES 8
    MAXLOGHISTORY 292
LOGFILE
  GROUP 1 '/oradata/orcl/redo01.log'  SIZE 50M BLOCKSIZE 512,
  GROUP 2 '/oradata/orcl/redo02.log'  SIZE 50M BLOCKSIZE 512,
  GROUP 3 '/oradata/orcl/redo03.log'  SIZE 50M BLOCKSIZE 512
-- STANDBY LOGFILE
DATAFILE
  '/oradata/orcl/system01.dbf',
  '/oradata/orcl/sysaux01.dbf',
  '/oradata/orcl/undotbs01.dbf',
  '/oradata/orcl/users01.dbf',
  '/oradata/test.dbf'
CHARACTER SET AL32UTF8;

SQL> alter database open RESETLOGS;

SQL> select open_mode from v$database;



表空间及数据文件管理:

-- 创建大小为50mb的永久表空间TEST01，禁止自动扩展数据文件
create tablespace TEST01
    logging
    datafile '/oradata/TEST01.dbf' size 50m
    reuse autoextend off;
	
select name from v$tablespace;	
select tablespace_name ,status from dba_tablespaces;
select tablespace_name,file_name from dba_data_files;



create tablespace TEST02
    logging
    datafile '/oradata/TEST02.dbf'  size 50m
    reuse autoextend on next 10m maxsize 200m
    extent management local;
 
注释:
开启自动扩展,每次扩展10M,最大扩展到200M,生产中一般低于30G
reuse autoextend on next 10m maxsize 200m

 

-- 创建永久表空间TEST03，允许自动扩展数据文件，本地管理方式，区分配方式为自动分配
create tablespace TEST03
    logging
    datafile'/oradata/TEST03.dbf' size 50m
    reuse autoextend on next 10m maxsize 200m
    extent management local autoallocate;

	
create tablespace TEST04
    logging
    datafile'/oradata/TEST04.dbf' size 50m
    reuse autoextend on next 10m maxsize 200m
    extent management local uniform size 10m;


6.3.4管理表空间
-- 通过alter tablespace命令该表空间中数据文件的位置（或名字）
--首先把该表空间设置为脱机状态
select tablespace_name ,status from dba_tablespaces;
alter tablespace TEST03 offline normal;
select tablespace_name ,status from dba_tablespaces;
-- 手动创建TEST03文件夹，并且复制TEST03.dbf到TEST03文件夹，重命名为TEST03_1.dbf
alter tablespace TEST03 rename datafile
    '/oradata/TEST03.dbf'
    to
    '/oradata/orcl/TEST03_1.dbf';
--最后把该表空间设置为联机状态
alter tablespace TEST03 online;

经典案例: 换存储


--删除表空间test01 及其对应的数据文件
drop tablespace test01 including contents and datafiles;









